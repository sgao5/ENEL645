# -*- coding: utf-8 -*-
"""ENEL645-FinalProject-Code-Group9.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dKf5nvL-JYxb60kE4drDPalIl1DuUja5

***ENEL 645 Final Project***

Objective: Develop machine learning techniques to predict load energy prediction based on the load history, weather and calendar paremeters.

Submitted by Group 9 members:
- Mohsen Tavakolian (30138728)
- Masoud Hajian Foroushani (30253439)
- Samuel Bakker (30104958)
- Sherry Gao (10194604)
- Gona Rahmaniani (30225142)

April 1, 2024

####**AESO Regions:**

![AESO Regions.JPG](data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAeAB4AAD/4QMARXhpZgAATU0AKgAAAAgABAE7AAIAAAASAAABSodpAAQAAAABAAABXJydAAEAAAAkAAAC1OocAAcAAAEMAAAAPgAAAAAc6gAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATW9oc2VuIFRhdmFrb2xpYW4AAAWQAwACAAAAFAAAAqqQBAACAAAAFAAAAr6SkQACAAAAAzc5AACSkgACAAAAAzc5AADqHAAHAAABDAAAAZ4AAAAAHOoAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADIwMjQ6MDI6MDEgMTk6NTM6MDkAMjAyNDowMjowMSAxOTo1MzowOQAAAE0AbwBoAHMAZQBuACAAVABhAHYAYQBrAG8AbABpAGEAbgAAAP/hBCRodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvADw/eHBhY2tldCBiZWdpbj0n77u/JyBpZD0nVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkJz8+DQo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIj48cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPjxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSJ1dWlkOmZhZjViZGQ1LWJhM2QtMTFkYS1hZDMxLWQzM2Q3NTE4MmYxYiIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIi8+PHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9InV1aWQ6ZmFmNWJkZDUtYmEzZC0xMWRhLWFkMzEtZDMzZDc1MTgyZjFiIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iPjx4bXA6Q3JlYXRlRGF0ZT4yMDI0LTAyLTAxVDE5OjUzOjA5Ljc5MjwveG1wOkNyZWF0ZURhdGU+PC9yZGY6RGVzY3JpcHRpb24+PHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9InV1aWQ6ZmFmNWJkZDUtYmEzZC0xMWRhLWFkMzEtZDMzZDc1MTgyZjFiIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iPjxkYzpjcmVhdG9yPjxyZGY6U2VxIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+PHJkZjpsaT5Nb2hzZW4gVGF2YWtvbGlhbjwvcmRmOmxpPjwvcmRmOlNlcT4NCgkJCTwvZGM6Y3JlYXRvcj48L3JkZjpEZXNjcmlwdGlvbj48L3JkZjpSREY+PC94OnhtcG1ldGE+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPD94cGFja2V0IGVuZD0ndyc/Pv/bAEMABwUFBgUEBwYFBggHBwgKEQsKCQkKFQ8QDBEYFRoZGBUYFxseJyEbHSUdFxgiLiIlKCkrLCsaIC8zLyoyJyorKv/bAEMBBwgICgkKFAsLFCocGBwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKv/AABEIAvMCvQMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APpGiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACgnAyaKZOdtvI3opP6UAecat41vNL1JrZQ8oUBifNI69uhqunxJugPmgkH/bUH/2Wue8T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oooAsXJJhtSf+eX/ALOwqvU9xnybbP8AzyOP++2qCnLcYUUUUhBRRRQAV0nhZv3jD/YP8xXN1veGGxd49Qw/QV1YR/vS47nV0UUV7BYUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAQX//ACDrn/rk38jU9NkRZY2jcZVgVI9Qarf2ZB/z0uv/AALl/wDiqALdFVP7Mg/56XX/AIFy/wDxVH9mQf8APS6/8C5f/iqALdFVP7Mg/wCel1/4Fy//ABVH9mQf89Lr/wAC5f8A4qgCaa2gufL+0Qxy+U4kj8xA2xx0YZ6EetS1U/syD/npdf8AgXL/APFUf2ZB/wA9Lr/wLl/+KoAt1EltBHcS3EcMaTTACSRUAZ8dMnqcdqh/syD/AJ6XX/gXL/8AFUf2ZB/z0uv/AALl/wDiqALdFVP7Mg/56XX/AIFy/wDxVH9mQf8APS6/8C5f/iqALdFVP7Mg/wCel1/4Fy//ABVH9mQf89Lr/wAC5f8A4qgC3RVT+zIP+el1/wCBcv8A8VR/ZkH/AD0uv/AuX/4qgC3UD/8AIRh/65SfzSo/7Mg/56XX/gXL/wDFVJBZQ28nmIZWbG3Mkzvge24nHQUAT0UUUAFFFFABRRRQAUUUUAFFFFABRRRQAVy+v6akUnmR/wAeSqgdPWuoqKa2huNvnoH29M9qicFOPKwPPvJk/wCebf8AfNL5Ev8Azzb8q7z+zbP/AJ4JS/YLT/n3j/75ri+pLuTyo4L7PL/cNL9mm/uGu++x2v8Az7Rf98ClFrbjpBH/AN8Cn9Sj3DlRwP2Wb+5+oo+yTf3f1Fd+IIh0iQf8BFOEaDoij6Cn9Sh3Hyo8/wDskvoPzpRZTN0A/OvQAAOgA+lLT+pw7hyo4AadcE4C/wA6eulXTdEJ+in/AArvKKf1OmHKjhhot2cfupP+/Zp40G7P/LN/++K7aiq+qUuwWRxg8PXZH3G/ID+tSDw1dk8oR/wJf8a6+in9Vpdgsuxyx8O3LxojDAQED5x65oHhebjJX8X/APrV1NFV9Xp9h6HNDws/8Tx/99H/AAp6+FhxudP1NdFRT9hT7BoYK+F4u8q/98f/AF6kHhq3HV8/8AFbVFV7KC6AZK+HbQdWf8AB/SrNtpVvaTLJEX3LnqR/hV2iqUUtkAUUUVQBRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB//Z)

#Description:

Public domain data from AESO have been used (https://www.aeso.ca/market/market-and-system-reporting/data-requests/hourly-load-by-area-and-region/) as the data source for training and prediction. The dataset incorporates energy load hourly data from January 2011 to October 2023 for 42 major cities and regions in Alberta, as shown in the map above.

Special thanks to **weathersource** (https://weathersource.com/products/onpoint-weather/) that provided us with hourly weather data in json format for the period of 2011 to 2023 (with 28 weather features). Special thank to weathersource.com for granting us free access to their valuable data.

#Summary:
In this study, we tried to explore different approaches that could help operators predict the energy load with high and acceptable accuracy for a desired period of time ahead. In a nutshell, we fulfilled these steps:


1.   Data collection and cleansing
2.   Feature engineering and data visualization
3.   Application of several machine learning (ML) techniques, including deterministic and probabilistic methods
4.   Applicability of transfer learning
5.   Choice of best model and overview of future work

**Note: The code has been developed by Google CoLab with the data stored on Drive.**

The first four lines to uninstall numpy, install a specific version of it, and then installation two libraries are a requirement for the last part of our project (probabilistic forecating). Gluonts library has some legacy which is not compatible with updated numpy.
"""

!pip uninstall numpy

!pip install numpy==1.23.3

!pip install gluonts

!pip install mxnet

# Commented out. We ran the code on Google Colab. Relevant code and dataset has been pushed to git repo.

# # Mount CoLab on Drive
# from google.colab import drive
# drive.mount('/content/drive')

import warnings

# Ignore all warning messages
# This is mainly to stop warning when we need to replace dataframe values in-place.
warnings.filterwarnings("ignore")

# Import libraries
import os
import json
import pandas as pd
import holidays
import random
from joblib import dump, load
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
from sklearn.ensemble import RandomForestRegressor
from statsmodels.tsa.arima.model import ARIMA
from sklearn.impute import SimpleImputer
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, MinMaxScaler
from sklearn.metrics import mean_squared_error, r2_score
import tensorflow as tf
from tensorflow.keras.models import Sequential, Model
from tensorflow.keras.layers import Input, Dense, concatenate, LSTM, Dropout, MultiHeadAttention, LayerNormalization, Flatten
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.callbacks import EarlyStopping
from sklearn.ensemble import StackingRegressor, GradientBoostingRegressor
from sklearn.neural_network import MLPRegressor
import statsmodels.api as sm
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
import statsmodels.api as sm
import joblib
import pickle
import pandas as pd

"""**Data Cleaning and Preparation**"""

# Define the path to the directory containing the processed data
# aeso_data_dir = "/content/drive/MyDrive/Colab Notebooks/Final Project/"
# relative path for git repo
aeso_data_dir = "./data"

"""With a separate code, data collected from AESO was cleaned and integrated in a single csv file. Since those steps are out of the scope of this project, we don't show them here, instead we read the final datafile, aeso_load_2011to2023.csv, from Drive."""

# Read the load data
alberta_load = pd.read_csv(aeso_data_dir + '/aeso_load_2011to2023.csv')

"""The following is the name of cities along with an overview of the database used:"""

alberta_load.describe()

alberta_load.columns

alberta_load

"""An important feature that was added to the database for modelling purpose is the impact of working and non-working (bank holidays and weekends) days, or the impact of calendar. This was done by Python's library, "holidays". The column values were defined as either zero for non-working days and unity for working days."""

# Get the bank holidays in Alberta for the years 2011 to 2023
ab_holidays = holidays.Canada(years=range(2011, 2023), prov='AB')

# Convert bank holidays to a pandas DataFrame
ab_holidays_df = pd.DataFrame(ab_holidays.items(), columns=['DATE', 'HOLIDAY'])

# Convert 'DATE' column to datetime
ab_holidays_df['DATE'] = pd.to_datetime(ab_holidays_df['DATE'])

# Create a list of AB holidays
ab_holidays_dates = ab_holidays_df['DATE']

# Define function to check if a date is a Saturday or Sunday
def is_weekend(date):
    return date.dayofweek in [5, 6]  # Saturday (5) or Sunday (6)

"""The following function retrieves a desired city's load data from the mother dataframe, alberta_load, reads the associated weather data json files, creates the working/nonworking column, and eventually merge all in an integrated dataframe with the name of the city chosen."""

def create_city_load_and_weather(load, city, selected_columns):
    city_load = alberta_load[['DATE', 'HOUR', city]]
    # Sort calgary_load DataFrame based on 'DATE' and then 'HOUR'
    city_load.sort_values(by=['DATE', 'HOUR'], inplace=True)

    # Define the directory path
    directory_path = './data/weathersource/' + city + '/'

    # Initialize an empty list to store DataFrames
    dfs = []

    # Iterate over each year from 2011 to 2023
    for year in range(2011, 2024):
        # Define the file path for the current year
        city_nospace = city.replace(' ','')
        file_path = os.path.join(directory_path, f'{city_nospace}-{year}.json')

        # Read the JSON file
        with open(file_path, 'r') as file:
            data = json.load(file)

        # Extract data associated with the 'history' key
        history_data = data['history']

        # Convert history_data to DataFrame
        history_df = pd.DataFrame(history_data)

        # Split timestamp into date and time components
        history_df[['DATE', 'TIME']] = history_df['timestamp'].str.split('T', expand=True)
        history_df['HOUR'] = pd.to_datetime(history_df['TIME']).dt.hour

        # Drop the 'timestamp' and 'TIME' columns
        history_df.drop(columns=['timestamp', 'TIME'], inplace=True)

        # Reorder the columns to have 'DATE' and 'HOUR' as the first two columns
        history_df = history_df[['DATE', 'HOUR'] + [col for col in history_df.columns if col not in ['DATE', 'HOUR']]]

        # Append the DataFrame to the list
        dfs.append(history_df)

    # Concatenate all DataFrames in the list
    city_weather_df = pd.concat(dfs, ignore_index=True)

    # Convert 'DATE' column to datetime
    city_weather_df['DATE'] = pd.to_datetime(city_weather_df['DATE'])

    # Sort DataFrame by 'DATE'
    city_weather_df.sort_values(by=['DATE', 'HOUR'], inplace=True)

    # Reset index
    city_weather_df.reset_index(drop=True, inplace=True)

    # Convert 'DATE' column in city_load to datetime if it's not already
    city_load['DATE'] = pd.to_datetime(city_load['DATE'])

    # Join city_load with city_weather_df based on 'DATE' and 'Hour'
    city_df = pd.merge(city_load, city_weather_df, left_on=['DATE', 'HOUR'], right_on=['DATE', 'HOUR'], how='inner')

    # Create a new column 'MONTH' containing the month component
    city_df['MONTH'] = city_df['DATE'].dt.month

    # Create a new column 'YEAR' containing the month component
    city_df['YEAR'] = city_df['DATE'].dt.year

    # Get the index of the 'DATE' column
    date_index = city_df.columns.get_loc('DATE')

    # Move the 'YEAR' column to be right after the 'DATE' column
    city_df.insert(date_index + 1, 'YEAR', city_df.pop('YEAR'))

    # Move the 'MONTH' column to be right after the 'YEAR' column
    city_df.insert(date_index + 2, 'MONTH', city_df.pop('MONTH'))

    # Rename the column
    city_df.rename(columns={city: 'Load'}, inplace=True)

    # Create a new column 'WORKING' with default value 1
    city_df['WORKING'] = 1

    # Set 'WORKING' to 0 for weekends
    city_df.loc[city_df['DATE'].apply(is_weekend), 'WORKING'] = 0

    # Set 'WORKING' to 0 for bank holidays
    city_df.loc[city_df['DATE'].isin(ab_holidays_dates), 'WORKING'] = 0

    # Get the index of the 'DATE' column
    date_index = city_df.columns.get_loc('DATE')

    # Move the 'MONTH' column to be right after the 'DATE' column
    city_df.insert(date_index + 1, 'WORKING', city_df.pop('WORKING'))

    # Filter data for working days and non-working days
    working_days_data = city_df[city_df['WORKING'] == 1]
    non_working_days_data = city_df[city_df['WORKING'] == 0]

    return city_df[selected_columns]

"""In this study, our home town, Calgary, was selected as the base city to develop the learning model. Furthermore, for the purpose of transfer learning investigation, Edmonton - as the closest city to Calgary in terms of population, area, life style, etc. - and Peace River - as a small town with less similarity to Calgary."""

# Choose some features to investigate their degree of importance
selected_columns = ['Load', 'MONTH', 'HOUR', 'WORKING', 'temp', 'feelsLike', 'mslPres', 'relHum', 'windSpd']

# Create dataframe for Calgary
calgary = create_city_load_and_weather(alberta_load, 'Calgary', selected_columns)
print(calgary)

"""**Feature Engineering**"""

# Calculate the correlation matrix
correlation_matrix = calgary.corr()

# Plot the correlation heatmap using Seaborn
plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f", linewidths=0.5)
plt.title('Correlation Heatmap for Calgary')
plt.show()

# Create dataframe for Edmonton
edmonton = create_city_load_and_weather(alberta_load, 'Edmonton', selected_columns)

# Calculate the correlation matrix
correlation_matrix = edmonton.corr()

# Plot the correlation heatmap using Seaborn
plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f", linewidths=0.5)
plt.title('Correlation Heatmap for Edmonton')
plt.show()

# Create dataframe for Peace River
peaceriver = create_city_load_and_weather(alberta_load, 'Peace River', selected_columns)

# Calculate the correlation matrix
correlation_matrix = peaceriver.corr()

# Plot the correlation heatmap using Seaborn
plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f", linewidths=0.5)
plt.title('Correlation Heatmap for Peace River')
plt.show()

# Calculate the correlation matrix
corr_matrix = calgary.corr()

# Extract the correlation of each feature with 'Load', excluding 'Load' itself
correlation_with_load = corr_matrix['Load'].abs().sort_values(ascending=False).drop('Load')

# Plot the correlation coefficients
plt.figure(figsize=(10, 6))
sns.barplot(x=correlation_with_load.values, y=correlation_with_load.index, palette='viridis')
plt.xlabel('Absolute Correlation Coefficient')
plt.ylabel('Feature')
plt.title('Feature Importance on Calgary Load (Correlation)')
plt.show()

# Calculate the correlation matrix
corr_matrix = peaceriver.corr()

# Extract the correlation of each feature with 'Load'
correlation_with_load = corr_matrix['Load'].abs().sort_values(ascending=False).drop('Load')

# Plot the correlation coefficients
plt.figure(figsize=(10, 6))
sns.barplot(x=correlation_with_load.values, y=correlation_with_load.index, palette='viridis')
plt.xlabel('Absolute Correlation Coefficient')
plt.ylabel('Feature')
plt.title('Feature Importance on Peace River Load (Correlation)')
plt.show()

# Calculate the correlation matrix
corr_matrix = edmonton.corr()

# Extract the correlation of each feature with 'Load', excluding 'Load' itself
correlation_with_load = corr_matrix['Load'].abs().sort_values(ascending=False).drop('Load')

# Plot the correlation coefficients
plt.figure(figsize=(10, 6))
sns.barplot(x=correlation_with_load.values, y=correlation_with_load.index, palette='viridis')
plt.xlabel('Absolute Correlation Coefficient')
plt.ylabel('Feature')
plt.title('Feature Importance on Edmonton Load (Correlation)')
plt.show()

"""The plots above show an obvious similarity between Calgary and Edmonton, while a totally different correlation between input and output features for the city of Peace River. This will be used as a justification evidence for the transfer learning section.
To further collect evidence for what we could expect to see, here is another visualization plot to show the similarity/dissimilarity among these three selected cities:
"""

# Plot load vs. HOUR for both working and non-working days
plt.figure(figsize=(10, 6))

# Plot working days data (blue color)
plt.scatter(calgary['HOUR'], calgary['Load'], color='blue', label='Working Days')

# Plot non-working days data with slight transparency (red color)
plt.scatter(calgary['HOUR'], calgary['Load'], color='red', alpha=0.1, label='Non-Working Days')

plt.xlabel('Hour')
plt.ylabel('Load (MWh)')
plt.title('Load vs. Hour for Calgary')
plt.legend()
plt.grid(True)
plt.show()

# Plot load vs. HOUR for both working and non-working days
plt.figure(figsize=(10, 6))

# Plot working days data (blue color)
plt.scatter(peaceriver['HOUR'], peaceriver['Load'], color='blue', label='Working Days')

# Plot non-working days data with slight transparency (red color)
plt.scatter(peaceriver['HOUR'], peaceriver['Load'], color='red', alpha=0.1, label='Non-Working Days')

plt.xlabel('Hour')
plt.ylabel('Load (MWh)')
plt.title('Load vs. Hour for Peace River')
plt.legend()
plt.grid(True)
plt.show()

# Plot load vs. HOUR for both working and non-working days
plt.figure(figsize=(10, 6))

# Plot working days data (blue color)
plt.scatter(edmonton['HOUR'], edmonton['Load'], color='blue', label='Working Days')

# Plot non-working days data with slight transparency (red color)
plt.scatter(edmonton['HOUR'], edmonton['Load'], color='red', alpha=0.1, label='Non-Working Days')

plt.xlabel('Hour')
plt.ylabel('Load (MWh)')
plt.title('Load vs. Hour for Edmonton')
plt.legend()
plt.grid(True)
plt.show()

"""Of all first chosen parameters, after some basic feature engineering analysis, the following can be selected for modelling which have the biggest impact on the load column (base on our base model, Calgary):

*   Hour of the day
*   Working/non-working day
*   Temperature
*   Relative humidity

Note: feelsLike strongly correlates with temperature, so it is not used in presence of temperature.
"""

selected_columns = ['DATE', 'HOUR', 'WORKING', 'Load', 'temp', 'relHum']
calgary = create_city_load_and_weather(alberta_load, 'Calgary', selected_columns)
peaceriver = create_city_load_and_weather(alberta_load, 'Peace River', selected_columns)
edmonton = create_city_load_and_weather(alberta_load, 'Edmonton', selected_columns)

# Plot all three datasets on the same plot
plt.figure(figsize=(15, 8))
plt.plot(edmonton['DATE'], edmonton['Load'], alpha=0.8, label='Edmonton')
plt.plot(calgary['DATE'], calgary['Load'], label='Calgary')
plt.plot(peaceriver['DATE'], peaceriver['Load'], label='Peace River')

# Add labels and legend
plt.xlabel('Date')
plt.ylabel('Load (MWh)')
plt.title('Load Comparison')
plt.legend()

"""The plot above shows that both minimum and maximum load values of Edmonton are higher than Calgary's, but their pattern over years are similar. The impact of this will be shown in the modelling section.
On the other hand, Peace River has not only a significantly lower load values, but also a completely different pattern over time. We will see the effect of this too.
"""

# Plot load vs. temperature for each city on the same plot
plt.figure(figsize=(15, 8))

# Plot load vs. temp for Calgary
plt.scatter(calgary['temp'], calgary['Load'], label='Calgary', alpha=0.5)

# Plot load vs. temp for Edmonton
plt.scatter(edmonton['temp'], edmonton['Load'], label='Edmonton', alpha=0.5)

# Plot load vs. temp for Peace River
plt.scatter(peaceriver['temp'], peaceriver['Load'], label='Peace River', alpha=0.5)

# Add labels and legend
plt.xlabel('Temperature (deg F)')
plt.ylabel('Load (MWh)')
plt.title('Load vs. Temperature for Different Cities')
plt.legend()

"""This is also another helpful plot to investigate the response of load to temperature, as an important feature that correlates strongly with load.

These are all helpful information to justify different models' similarity and dissimilarity

**Data Preparation**

Looking for missing values:
"""

# Iterate over each column
for column in calgary.columns:
    # Count the number of rows with null or zero values for the current column
    num_rows_with_null = (calgary[column].isnull()).sum()

    # Print the column name and the number of rows with null or zero values
    print(f"Column '{column}': {num_rows_with_null} rows with null values")

# Iterate over each column
for column in peaceriver.columns:
    # Count the number of rows with null or zero values for the current column
    num_rows_with_null = (peaceriver[column].isnull()).sum()

    # Print the column name and the number of rows with null or zero values
    print(f"Column '{column}': {num_rows_with_null} rows with null values")

# Iterate over each column
for column in edmonton.columns:
    # Count the number of rows with null or zero values for the current column
    num_rows_with_null = (edmonton[column].isnull()).sum()

    # Print the column name and the number of rows with null or zero values
    print(f"Column '{column}': {num_rows_with_null} rows with null values")

# Find rows where DEMAND is zero
rows_with_zero_demand = calgary[calgary['Load'] == 0]

# Print the rows with zero DEMAND
print("Rows with DEMAND = 0:")
print(rows_with_zero_demand)

# Find rows where DEMAND is zero
rows_with_zero_demand = peaceriver[peaceriver['Load'] == 0]

# Print the rows with zero DEMAND
print("Rows with DEMAND = 0:")
print(rows_with_zero_demand)

# Find rows where DEMAND is zero
rows_with_zero_demand = edmonton[edmonton['Load'] == 0]

# Print the rows with zero DEMAND
print("Rows with DEMAND = 0:")
print(rows_with_zero_demand)

"""Splitting for training:
We first chose 2011 to 2018 for training, 2019 and 2020 for validation, and 2021 to 2023 for testing. However, we observed (as shown below for one of our best matched models) that the model was not able to predict the higher end values of load with similar accuracy of the rest of the test dataset. As shown below, for a chunk of load column, the actual (normalized) values went above 1, while the predicted load for this piece of data never went beyond unity. This showed higher consumption (load values) by the city of Calgary in the recent years (2021-2023) that had been chosen for the test dataset (data normalization is based on the train dataset). The reason could be higher poulation and growth rate of the city in the resent years.
As a result, we decided to reverse the direction of our data split and chose:

*   Train: 2016 -2023
*   Validation: 2014 - 2015
*   Test: 2011 - 2013

![image.png](data:image/png;base64,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9oKo8Jr7GgVRXomwS0GUICpsj6ux2gRR1WtwQVR47QVR4TX3NQqivBJhl4KoKkLUL37xC+vQoYP17t3b/v3vf9dp+eXLl9ugQYPcMRMnTqyzP7rhd7/7nY0ikniMPfHEE7aGSOGyoAoIooLKnVWZICpLjiAfBFFBZM5biSAqryypbxREVQmi7r//fuvUqZN99NFHNmfOHOvcubN9Qm65jfbZZ5/ZV77yFQO01q1bZ7vvvrs99NBDfned5bx58wRRdVSp/gYg6mMSOMuCKyCICi65+w577LHHwlesGk0QVZ1OIIiqEkQNGzbMpkyZkmn1rl272tNPP535jGdqv/32sw82xli66aab7IQTTsjsz13hgTF69OjczZnPeKLWrl2b+ayVMAosWrTIQXCY2lRLVIEHH3ww+lHrART49NNPTRAVQOg8Vbz44ou2YsWKPHu0KU0FeG6/S6zEGrZ27drF3v1msXsq3NG/f397+OGHM6X069cv6/Mbb7xhXbp0MdzjGB6N7t27Z45n5a677rIddtjBOnbsaK1atbKhQ4caD208VjxA/B/13HfffQZo5e7zx2i5Sa+ktED3e++917WDdE9e3/raCe1nz57t/k/Vd5z2Jdcu9HH+8Kyjv7RNTttCWqI7oxsPPPCAvuMjz75CulW6n34+d+5c+/3vf1+TunP/jz76qBtJy4KTyIfUIGrgwIHuAevr6tOnj/3hD3/wH90vCjxR60mpYuYaieG9OFuwYIGNGTMmbrc99dRT9v7778fu1450FFi8eLH973//S6dwlVqvAjxYZOEV4LtIFl6Bl156yVauXBm+4hqv8a9//autXr26plWoiifqmmuusSFDhjjh//Of/1ibNm3svffes1WrVjnvE3OlunXrlhniO+WUU+xaYi/FmOZExQhT5c2aWF69BtCcqPDaa2J5eM19jZoT5ZUIu9ScqCrNicI70bdvXzviiCPc3Kfp06e7lt91112dS5YPt9xyixvC45iePXsak83jTG/nxSlT3e2CqOrpL4gKr70gKrzmvkZBlFci7FIQVSWIopl5647JgP/85z8zrf7mm29mTUR+66233DF4puozPFHf//73Yw95/vnnNawUq056OxhGlVVHgejweHWuoDZrXbp0aW3eeJXv+vXXX1cYmyq0AcOohZ7PVbisoFVWZTgv6TtkAjM38pOf/MQuueSSrL/x48fbyJEj7cILL7RLL700a1/usfqcrV0levzoRz+yESNG2MUXXyzdc/pkJboWcy59/owzzjCWxRyvYyrv93y38HfmmWdK98D9ne+ac88918aOHWusqz9X3p+L0ZDvl3POOcd+8IMf1KTunid22223WKRJbWJ5bI1l7mBC4c0332y333673XbbbVl/99xzjx1wwAE2YcIEu+OOO7L25R6rz9naVaIHb4ftscceNnnyZPvtb38r3XP6ZSXa1ncu/wfuvPNOa9GihXtDr75jtS+5/j5z5kz3HbTjjjtK90B93fffu+++2772ta/Zd7/7XffWtt+uZXL9O5+W6P6lL33JLrroIps1a1ZNfsf/5je/yYoskIswjQaici889zPhDxg6lIVVgHlvvDggC69AfS7m8FdTOzV+8YtfrJ2bbUB3igeK8BKysAoMHz7ciMMoy69Ak4Gor3/962ro/G2c6lYeKP/6179SrUOF51dg2223zb9DW1NT4MMPP7T27dunVr4Kjlfge9/7nuEVkIVV4OSTT3axksLW2nhqazIQRRC2fPn5Gk9TNM4rJSAqDxZZeAWI8i8LqwCpqxj2kIVXYMmSJfbKK6+Er7jGayQeHS+AyfIr0GQgKv/taasUkAJSQApIASkgBdJRQBCVjq4qVQpIASkgBaSAFGjiCgiimngD6/akgBSQAlJACkiBdBRolBD14x//2Pbcc0+78sor86qyfPly69Gjh4uCHg30mfdgbSxaAWKFdO7c2YU0yD2JQHjf+c53bN9997VBgwYZ2e5lyShAf+YtyAMPPNCeffbZ2EL/9re/uX7/2muvxR6jHcUrsGzZMvcdcvDBBxsJ0/MZgTd79+5t++yzjwu/ku8YbStNAfo4eVXJt7p27do6J5NvldhFe+21l4uVVl+mizona0OsAgSsPvbYY11fjntufvzxx0aO265du5qCzm6QstFB1Lhx4+ywww5z0clJF8ODPWpMgGvZsqU999xzRrj6rbfe2uXrix6j9dIV4DVX8hsyiZyHCrkRo0aWb+IX8QXHZPOddtpJIBUVqMx1XpYgVRKZxJ955hlr1qxZ3kTbb7/9th100EEOtPQ6cpliR07jRwFvP/JgYUIz3yO5UZtJRcWPNZKzkg5G8BoRsMxVvrc/97nPGZktHn74YdcGuQnOiRd1/vnnuxrIYsHzQFa5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)
```
Underprediction of higher end values with the initial data split
```
"""

# Split the data into training, validation, and testing sets
training_data = calgary[(calgary['DATE'].dt.year >= 2016)]
validation_data = calgary[(calgary['DATE'].dt.year.isin([2014, 2015]))]
testing_data = calgary[(calgary['DATE'].dt.year.isin([2011, 2012, 2013]))]

# Print the shapes of the data subsets
print("Training data shape:", training_data.shape)
print("Validation data shape:", validation_data.shape)
print("Testing data shape:", testing_data.shape)

# Separate features (X) and target variable (y) for training, validation, and testing sets
X_train = training_data.drop(columns=['Load'])
y_train = training_data['Load']
X_validation = validation_data.drop(columns=['Load'])
y_validation = validation_data['Load']
X_test = testing_data.drop(columns=['Load'])
y_test = testing_data['Load']

X_peaceriver = peaceriver.drop(columns=['Load'])
y_peaceriver = peaceriver['Load']

X_edmonton = edmonton.drop(columns=['Load'])
y_edmonton = edmonton['Load']

# Drop the Date column as we don't need it during ML process
X_train = X_train.drop(columns=['DATE'])
X_validation = X_validation.drop(columns=['DATE'])
X_test = X_test.drop(columns=['DATE'])

X_peaceriver = X_peaceriver.drop(columns=['DATE'])
X_edmonton = X_edmonton.drop(columns=['DATE'])

# Check for missing data in X_train
missing_data_X_train = X_train.isnull().sum()
print("Missing data in X_train:")
print(missing_data_X_train)

# Check for missing data in y_train
missing_data_y_train = y_train.isnull().sum()
print("\nMissing data in y_train:")
print(missing_data_y_train)

# Check for missing data in X_validation
missing_data_X_validation = X_validation.isnull().sum()
print("\nMissing data in X_validation:")
print(missing_data_X_validation)

# Check for missing data in y_validation
missing_data_y_validation = y_validation.isnull().sum()
print("\nMissing data in y_validation:")
print(missing_data_y_validation)

# Check for missing data in X_test
missing_data_X_test = X_test.isnull().sum()
print("\nMissing data in X_test:")
print(missing_data_X_test)

# Check for missing data in y_test
missing_data_y_test = y_test.isnull().sum()
print("\nMissing data in y_test:")
print(missing_data_y_test)

# Convert y_train to DataFrame with column name 'DEMAND'
y_train = y_train.to_frame(name='Load')

# Convert y_validation to DataFrame with column name 'DEMAND'
y_validation = y_validation.to_frame(name='Load')

# Convert y_test to DataFrame with column name 'DEMAND'
y_test = y_test.to_frame(name='Load')

y_peaceriver = y_peaceriver.to_frame(name='Load')
y_edmonton = y_edmonton.to_frame(name='Load')

# Extract input and output names
input_cols = X_train.columns
output_col = y_train.columns

print(output_col)

# Standardize the input features
std_scaler_input = StandardScaler()

# Fit and transform input features for training set (Standardization)
train_data_standardized_input = std_scaler_input.fit_transform(X_train[input_cols])

# Transform input features for testing and validation sets (Standardization)
test_data_standardized_input = std_scaler_input.transform(X_test[input_cols])
validation_data_standardized_input = std_scaler_input.transform(X_validation[input_cols])

peaceriver_standardized_input = std_scaler_input.transform(X_peaceriver[input_cols])
edmonton_standardized_input = std_scaler_input.transform(X_edmonton[input_cols])

# Normalize the standardized input features
norm_scaler_input = MinMaxScaler()

# Fit and transform input features for training set (Normalization)
train_data_normalized_input = norm_scaler_input.fit_transform(train_data_standardized_input)

# Transform input features for testing and validation sets (Normalization)
test_data_normalized_input = norm_scaler_input.transform(test_data_standardized_input)
validation_data_normalized_input = norm_scaler_input.transform(validation_data_standardized_input)

peaceriver_normalized_input = norm_scaler_input.transform(peaceriver_standardized_input)
edmonton_normalized_input = norm_scaler_input.transform(edmonton_standardized_input)

# Standardize the output vector
std_scaler_output = StandardScaler()

# Fit and transform output feature for training set (Standardization)
train_data_standardized_output = std_scaler_output.fit_transform(y_train[output_col])

# Transform output feature for testing and validation sets (Standardization)
test_data_standardized_output = std_scaler_output.transform(y_test[output_col])
validation_data_standardized_output = std_scaler_output.transform(y_validation[output_col])

peaceriver_standardized_output = std_scaler_output.transform(y_peaceriver[output_col])
edmonton_standardized_output = std_scaler_output.transform(y_edmonton[output_col])

# Normalize the standardized output vector
norm_scaler_output = MinMaxScaler()

# Fit and transform output feature for training set (Normalization)
train_data_normalized_output = norm_scaler_output.fit_transform(train_data_standardized_output)

# Transform output feature for testing and validation sets (Normalization)
test_data_normalized_output = norm_scaler_output.transform(test_data_standardized_output)
validation_data_normalized_output = norm_scaler_output.transform(validation_data_standardized_output)

peaceriver_normalized_output = norm_scaler_output.transform(peaceriver_standardized_output)
edmonton_normalized_output = norm_scaler_output.transform(edmonton_standardized_output)

"""**Modelling**

Generally speaking, we have tried two types of modelling, with and without considering the time series nature of ourdataset.
Starting from a regular training, without considering the impact of load history (disregarding its time series nature), we practiced several methods like Random Forest Regressor, Neural Networks, Gradient Boosting, etc. Almost all of them offered similar accuracies. Of those, we present GBM here.

**1. Gradient Boosting Model (GBM)**
"""

# Initialize and train the GBM model
gbm_model = GradientBoostingRegressor(n_estimators=100, max_depth=5, random_state=42)
gbm_model.fit(train_data_normalized_input, train_data_normalized_output.ravel())

# Predict on validation set
validation_predictions = gbm_model.predict(validation_data_normalized_input)

# Calculate validation RMSE
validation_rmse = np.sqrt(mean_squared_error(validation_data_normalized_output, validation_predictions))
# Calculate R-squared for validation set
validation_r2 = r2_score(validation_data_normalized_output, validation_predictions)

# Predict on test set
test_predictions = gbm_model.predict(test_data_normalized_input)

# Calculate test RMSE
test_rmse = np.sqrt(mean_squared_error(test_data_normalized_output, test_predictions))
# Calculate R-squared for test set
test_r2 = r2_score(test_data_normalized_output, test_predictions)

# Plot actual vs predicted values for validation set
plt.figure(figsize=(10, 6))
plt.scatter(validation_data_normalized_output, validation_predictions, color='blue', label='Validation Data')
plt.xlabel('Actual Normalized-Standardized Load')
plt.ylabel('Predicted Normalized-Standardized Load')
plt.title('GBM: Actual vs Predicted (Validation)')
plt.legend()
plt.grid(True)
plt.show()

# Print RMSE and R-squared for validation set
print("Validation RMSE:", validation_rmse)
print("Validation R-squared:", validation_r2)

# Plot actual vs predicted values for test set
plt.figure(figsize=(10, 6))
plt.scatter(test_data_normalized_output, test_predictions, color='red', label='Test Data')
plt.xlabel('Actual Normalized-Standardized Load')
plt.ylabel('Predicted Normalized-Standardized Load')
plt.title('GBM: Actual vs Predicted (Test)')
plt.legend()
plt.grid(True)
plt.show()


# Print RMSE and R-squared for test set
print("Test RMSE:", test_rmse)
print("Test R-squared:", test_r2)

"""As presented above, when each row of data is interpreted individually without considering the dependency to their history (time series), the average accuracy would not be great. Note that the prediction is just for one time step ahead, and an average accuracy of 82% would not be impressive when the target is prediction of some days ahead. (The single point prediction is used in a loop to be considered as the input for the next cycle. For a target of 3 days prediction, for instance, the uncertainty is accumulated in 72 cycles. Thus, we need a much higher average accuracy for "single point prediction" to be able to deliver a quality product.)

Now that we learned we cannot ignore the dependency nature of our data, let's present the models that include the time series properties. But before we dive into it, we first need to address some fundamental and basic questions; e.g. how deep we should let the model to look back and learn from its history, how we should implement this history, do other parameters have a lag to impact the output value, ...

ACF feature analysis to find the proper timestep history: Autocorrelation Function (ACF) is a helpful tool for understanding the correlation between a time series and its lagged values. The ACF provides insights into the temporal dependencies within the time series data.
"""

# 'Calgary Load' is the target variable
target_variable = y_train['Load']

# Calculate ACF and PACF
acf = sm.tsa.acf(target_variable, fft=False)

# Plot ACF
plot_acf(target_variable, lags=72)  # Adjust lags as needed
plt.title('Autocorrelation Function (ACF)')
plt.xlabel('Lag')
plt.ylabel('Autocorrelation')
plt.show()

"""As can be seen, each time step (originated at point zero), has the strongest dependency to its first preceding step, as expected, which then decreases and becomes almost no dependencies to the 7th preceding time step. The correlation keeps dropping until it reaches the most negative value at the 12th lag (most powerful reverse correlation which is also considered an important point for the modelling stage - similar to correlation matrix). The dependency again grows to the highest peak (except the first preceding time step) at the 24th preceding hour.
We can now utilize these important historical points with different approaches; e.g. using only the peak points, using the full history points up to the trough (12 hours in this case), using full history of the last 24 hours. We will compare the result of each approach.

**2. Random Forest with Time Series Features**
"""

# Prepare lagged features for the time series data
def create_lagged_features(data, lag):
    lagged_features = [data.shift(i) for i in range(1, lag)]
    return pd.concat([data] + lagged_features, axis=1)

# Columns to build the timeseries dataframes
input_cols = input_cols.tolist()

"""This is the function to create a time series dataframe with the desired lag. The result will be a dataframe including the input and output features plus the preceding load data (as additional input features) for lag-value time steps back."""

# Function to fill in the timeseries dataframes
def fill_timeseries_df(input, output, lag):
    # Shifted dataframe
    lagged_load = create_lagged_features(pd.DataFrame(output)[0], lag)
    lagged_load = lagged_load.transpose().iloc[::-1].iloc[:, lag-1:]

    # Create an empty DataFrames
    timeseries_df = pd.DataFrame(columns=['load ' + str(i) + 'hr bk' for i in range(lag, 0, -1)] + input_cols)

    # Number of iterations
    num_iterations = int((output.shape[0] - lag) / lag)

    # Define an empty list to store column-wise DataFrames
    dfs = []

    # Fill timeseries_train column-wise
    for iteration in range(num_iterations):
        df_list = []
        for i in range(iteration * lag + 1, (iteration + 1) * lag + 1):
            # Create a dictionary to store column data
            column_data = {
                input_cols[0] : input[i-1+lag][0],
                input_cols[1] : input[i-1+lag][1],
                input_cols[2] : input[i-1+lag][2],
                input_cols[3] : input[i-1+lag][3],
                'Load': output[i-1+lag][0]
            }

            # Fill load columns from lagged_load
            for j in range(lag):
                column_data['load ' + str(j + 1) + 'hr bk'] = lagged_load.iloc[lag - j - 1, i - 1]

            # Append the column data to the list
            df_list.append(pd.DataFrame([column_data]))

        # Concatenate the DataFrames in the list
        df_concat = pd.concat(df_list, ignore_index=True)

        # Append the concatenated DataFrame to the list
        dfs.append(df_concat)

    # Concatenate all DataFrames in the list along axis 1 (columns)
    timeseries_df = pd.concat(dfs, axis=0, ignore_index=True)

    return timeseries_df

lag = 24
timeseries_train = fill_timeseries_df(train_data_normalized_input, train_data_normalized_output, lag)
timeseries_valid = fill_timeseries_df(validation_data_normalized_input, validation_data_normalized_output, lag)
timeseries_test = fill_timeseries_df(test_data_normalized_input, test_data_normalized_output, lag)

timeseries_train

# Separate input and output features
X = timeseries_train.drop(columns=['Load'])  # Input features (all columns except 'Load', the output feature)
y = timeseries_train['Load']  # Output feature

# Train a Random Forest model
rf_model = RandomForestRegressor(n_estimators=100, random_state=42)
rf_model.fit(X, y)

"""We can save the model for further use which would save time to utilize it without the need to re-run all the steps. The model can be recalled by load method:

```
# Save the trained model to a file
dump(rf_model, aeso_data_dir + '/models/rf_model_calgary.joblib')

# Later, to load the model back into memory
rf_model = load(aeso_data_dir + '/models/rf_model_calgary.joblib')
```


"""

# Predict on validation set
validation_predictions_rf = rf_model.predict(timeseries_valid.drop(columns=['Load']))

# Calculate R^2
validation_r2_rf = r2_score(timeseries_valid['Load'], validation_predictions_rf)

# Calculate RMSE
validation_rmse_rf = np.sqrt(mean_squared_error(timeseries_valid['Load'], validation_predictions_rf))

print("Random Forest with Time Series Features (Ensembling):")
print("Validation RMSE:", validation_rmse_rf)
print("Validation R-squared:", validation_r2_rf)

# Plot actual vs predicted values for validation set
plt.figure(figsize=(10, 6))
plt.scatter(timeseries_valid['Load'], validation_predictions_rf, color='red', label='Validation Data')
plt.xlabel('Actual Normalized-Standardized Load')
plt.ylabel('Predicted Normalized-Standardized Load')
plt.title('Time Series & Random Forest: Actual vs Predicted (Validation)')
plt.legend()
plt.grid(True)
plt.show()

# Print RMSE and R-squared for validation set
print("Validation RMSE:", validation_rmse_rf)
print("Validation R-squared:", validation_r2_rf)

# Predict on test set
test_predictions_rf = rf_model.predict(timeseries_test.drop(columns=['Load']))

# Calculate R^2
test_r2_rf = r2_score(timeseries_test['Load'], test_predictions_rf)

# Calculate RMSE
test_rmse_rf = np.sqrt(mean_squared_error(timeseries_test['Load'], test_predictions_rf))

print("Random Forest with Time Series Features (Ensembling):")
print("Test RMSE:", test_rmse_rf)
print("Test R-squared:", test_r2_rf)

# Plot actual vs predicted values for test set
plt.figure(figsize=(10, 6))
plt.scatter(timeseries_test['Load'], test_predictions_rf, color='blue', label='Test Data')
plt.xlabel('Actual Normalized-Standardized Load')
plt.ylabel('Predicted Normalized-Standardized Load')
plt.title('Time Series & Random Forest: Actual vs Predicted (Test)')
plt.legend()
plt.grid(True)
plt.show()

# Print RMSE and R-squared for test set
print("Test RMSE:", test_rmse_rf)
print("Test R-squared:", test_r2_rf)

"""Predicting hours ahead in a loop:
Now that we have a trained model with quite high average accuracy (validated and tested), we can try predicting the load for an upcoming period of time. In this study we target three days (72 hours) prediction.
"""

def multiple_prediction(timeseries, pred_hr, model):
    # Choose a random starting index
    random_start_index = np.random.randint(low=0, high=len(timeseries) - pred_hr + 1)  # To ensure enough rows remain

    # Select the next 72 rows following the random starting index
    random_rows = timeseries.iloc[random_start_index:random_start_index + pred_hr]

    # Save the actual load before it changes
    actual_load = random_rows['Load'].copy()

    for hr in range(pred_hr):
        pred = model.predict(pd.DataFrame(random_rows.iloc[hr]).transpose().drop(columns=['Load']))
        random_rows['Load'][random_start_index + hr] = pred
        hr_bk = random_start_index + hr
        for future_hr in range(1, lag+1):
            hr_bk = hr_bk + 1
            if hr_bk < random_start_index + pred_hr:
                random_rows[f'load {str(future_hr)}hr bk'][hr_bk] = pred

    return (actual_load, random_rows, random_start_index)

pred_hr = 72
actual_load, prediction, random_start_index = multiple_prediction(timeseries_test, pred_hr, rf_model)

prediction # Normalized values

# Plot actual vs. predicted loads for 72 hours ahead
plt.plot(actual_load, label='Actual Load', color='blue')
plt.plot(prediction['Load'], label='Predicted Load', color='red')
plt.xlabel('Time')
plt.ylabel('Load')
plt.title('Actual vs Predicted Load on a Random Date (Calgary - Normalized Load)')
plt.legend()
plt.show()

# Calculate R-squared (r2) and Root Mean Squared Error (RMSE)
r2 = r2_score(actual_load, prediction['Load'])
rmse = np.sqrt(mean_squared_error(actual_load, prediction['Load']))

# Print r2 and rmse
print(f'R-squared (r2): {r2}')
print(f'Root Mean Squared Error (RMSE): {rmse}')

# De-normalize de-standardize the actual and predicted loads
actual_load_denorm = std_scaler_output.inverse_transform(norm_scaler_output.inverse_transform(actual_load.to_numpy().reshape(-1, 1)))
predicted_load_denorm = std_scaler_output.inverse_transform(norm_scaler_output.inverse_transform(prediction['Load'].to_numpy().reshape(-1, 1)))

# Extract the first point of time (timestamp) from testing_data
first_point_of_time = testing_data['DATE'][random_start_index + 12]

# Extract the hour from testing_data at the first point of time
first_hour = testing_data['HOUR'][random_start_index + 12]

# Create the x-axis values starting from the first point of time and extending to pred_hr hours more
x_values = pd.date_range(start=first_point_of_time, periods=pred_hr, freq='H')

# Calculate R-squared (r2) and Root Mean Squared Error (RMSE)
r2_denorm = r2_score(actual_load, prediction['Load'])
rmse_denorm = np.sqrt(mean_squared_error(actual_load, prediction['Load']))

# Plot actual vs. predicted loads for the hours ahead
plt.plot(x_values, actual_load_denorm, label='Actual Load', color='blue')
plt.plot(x_values, predicted_load_denorm, label='Predicted Load', color='red')
plt.xlabel('Time')
plt.ylabel('Load (MWh)')
plt.title('Actual vs Predicted Load (Original Values)')
plt.xticks(rotation=45)
plt.legend()
plt.show()

# Print r2 and rmse
print(f'R-squared (r2): {r2_denorm}')
print(f'Root Mean Squared Error (RMSE): {rmse_denorm} MWh')

"""**Modelling with only 3 history points (first preceding, trough - 12 hours back, and peak - 24 hours back)**"""

selective_cols = input_cols.copy() + ['load 1hr bk', 'load 12hr bk', 'load ' + str(lag) + 'hr bk']

# Separate input and output features
X = timeseries_train[selective_cols]
y = timeseries_train['Load']  # Output feature

# Train a Random Forest model
rf_model_selective_peaks = RandomForestRegressor(n_estimators=100, random_state=42)
rf_model_selective_peaks.fit(X, y)

# Predict on validation set
validation_predictions_rf = rf_model_selective_peaks.predict(timeseries_valid[selective_cols])

# Calculate R^2
validation_r2_rf = r2_score(timeseries_valid['Load'], validation_predictions_rf)

# Calculate RMSE
validation_rmse_rf = np.sqrt(mean_squared_error(timeseries_valid['Load'], validation_predictions_rf))

print("Random Forest with Selective Time Series Features (Ensembling):")
print("Validation RMSE:", validation_rmse_rf)
print("Validation R-squared:", validation_r2_rf)

# Plot actual vs predicted values for validation set
plt.figure(figsize=(10, 6))
plt.scatter(timeseries_valid['Load'], validation_predictions_rf, color='red', label='Validation Data')
plt.xlabel('Actual Normalized-Standardized Load')
plt.ylabel('Predicted Normalized-Standardized Load')
plt.title('Selective Peak Points & Random Forest: Actual vs Predicted (Validation)')
plt.legend()
plt.grid(True)
plt.show()

# Print RMSE and R-squared for validation set
print("Validation RMSE:", validation_rmse_rf)
print("Validation R-squared:", validation_r2_rf)

selective_cols = input_cols.tolist().copy() + ['load 1hr bk', 'load 12hr bk', 'load ' + str(lag) + 'hr bk']
pred_hr = 72
selective_cols += ['Load']
# Choose a random starting index
random_start_index = np.random.randint(low=0, high=len(timeseries_test[selective_cols]) - pred_hr + 1)  # To ensure enough rows remain
# Select the next 72 rows following the random starting index
prediction = timeseries_test[selective_cols].iloc[random_start_index:random_start_index + pred_hr]
# Save the actual load before it changes
actual_load = prediction['Load'].copy()
for hr in range(pred_hr):
    pred = rf_model_selective_peaks.predict(pd.DataFrame(prediction.iloc[hr]).transpose().drop(columns=['Load']))
    prediction['Load'][random_start_index + hr] = pred
    hr_bk = random_start_index + hr
    for future_hr in [1, 12, lag]:
        hr_bk = hr_bk + 1
        if hr_bk < random_start_index + pred_hr:
            prediction[f'load {str(future_hr)}hr bk'][hr_bk] = pred

# Plot actual vs. predicted loads for 72 hours ahead
plt.plot(actual_load, label='Actual Load', color='blue')
plt.plot(prediction['Load'], label='Predicted Load', color='red')
plt.xlabel('Time')
plt.ylabel('Load')
plt.title('Actual vs Predicted Load on a Random Date (Calgary - Normalized Load)')
plt.legend()
plt.show()

# Calculate R-squared (r2) and Root Mean Squared Error (RMSE)
r2 = r2_score(actual_load, prediction['Load'])
rmse = np.sqrt(mean_squared_error(actual_load, prediction['Load']))

# Print r2 and rmse
print(f'R-squared (r2): {r2}')
print(f'Root Mean Squared Error (RMSE): {rmse}')

"""This was a showcase to compare the efficiency of our previous model with full 24 hours history consideration instead of only the peaks and first preceding data point. Despite the high average accuracy of 99.29% on the validation dataset, we can see that it fails to predict the hours ahead, beyond just a few hours of interest. The 99.29% average accuracy is based on a single point (1 hour in this case) prediction, but the accumulated error grows significantly when the prediction is put in a loop.

**Transfer Learning, Universal Model**
"""

# Predict on Edmonton set
timeseries_edmonton = fill_timeseries_df(edmonton_normalized_input, edmonton_normalized_output, lag)
edmonton_predictions_rf = rf_model.predict(timeseries_edmonton.drop(columns=['Load']))

# Calculate R^2
edmonton_r2_rf = r2_score(timeseries_edmonton['Load'], edmonton_predictions_rf)

# Calculate RMSE
edmonton_rmse_rf = np.sqrt(mean_squared_error(timeseries_edmonton['Load'], edmonton_predictions_rf))

print("Random Forest with Time Series Features (Ensembling):")
print("Validation RMSE:", edmonton_rmse_rf)
print("Validation R-squared:", edmonton_r2_rf)

# Plot actual vs predicted values for Edmonton set
plt.figure(figsize=(10, 6))
plt.scatter(timeseries_edmonton['Load'], edmonton_predictions_rf, color='green', label='Edmonton Data')
plt.xlabel('Actual Normalized-Standardized Load')
plt.ylabel('Predicted Normalized-Standardized Load')
plt.title('Time Series & Random Forest: Actual vs Predicted (Edmonton)')
plt.legend()
plt.grid(True)
plt.show()

# Print RMSE and R-squared for test set
print("Edmonton RMSE:", edmonton_rmse_rf)
print("Edmonton R-squared:", edmonton_r2_rf)

"""We should remember this plot for the next section. As can be seen in the plot above, a chunk of data towards the tail has actual normalized data above unity while their prediction is below and not more than one. Since the data has been normalized by Calgary train dataset, this is an evidence of higher range of Edmonton's load values than Calgary's. To investigate how much this impacts the transfer learning efficiency, we will develop a model by Edmonton's data and try to predict Calgary's load with it after a more visual plot of how transfer learning from Calgary to Edmonton could predict 72 hours ahead."""

# Prediction of Edmonton by Calgary model
actual_load, random_rows, random_start_index = multiple_prediction(timeseries_edmonton, pred_hr, rf_model)

# De-normalize de-standardize the actual and predicted loads
actual_load_denorm = std_scaler_output.inverse_transform(norm_scaler_output.inverse_transform(actual_load.to_numpy().reshape(-1, 1)))
predicted_load_denorm = std_scaler_output.inverse_transform(norm_scaler_output.inverse_transform(random_rows['Load'].to_numpy().reshape(-1, 1)))

# Extract the first point of time (timestamp) from Edmonton data
first_point_of_time = edmonton['DATE'][random_start_index + 12]

# Extract the hour from testing_data at the first point of time
first_hour = edmonton['HOUR'][random_start_index + 12]

# Create the x-axis values starting from the first point of time and extending to pred_hr hours more
x_values = pd.date_range(start=first_point_of_time, periods=pred_hr, freq='H')

# Plot actual vs. predicted loads for the hours ahead
plt.plot(x_values, actual_load_denorm, label='Actual Load', color='blue')
plt.plot(x_values, predicted_load_denorm, label='Predicted Load', color='red')
plt.xlabel('Time')
plt.ylabel('Load (MWh)')
plt.title('Actual vs Predicted Load (Edmonton Data)')
plt.xticks(rotation=45)
plt.legend()
plt.show()

# Calculate R-squared (r2) and Root Mean Squared Error (RMSE)
r2 = r2_score(actual_load, random_rows['Load'])
rmse = np.sqrt(mean_squared_error(actual_load, random_rows['Load']))

# Print r2 and rmse
print(f'R-squared (r2): {r2}')
print(f'Root Mean Squared Error (RMSE): {rmse}')

"""Prediction of Peace River by Calgary Model"""

# Predict on Peace River set
timeseries_peaceriver = fill_timeseries_df(peaceriver_normalized_input, peaceriver_normalized_output, lag)
peaceriver_predictions_rf = rf_model.predict(timeseries_peaceriver.drop(columns=['Load']))

# Calculate R^2
peaceriver_r2_rf = r2_score(timeseries_peaceriver['Load'], peaceriver_predictions_rf)

# Calculate RMSE
peaceriver_rmse_rf = np.sqrt(mean_squared_error(timeseries_peaceriver['Load'], peaceriver_predictions_rf))

print("Random Forest with Time Series Features (Ensembling):")
print("Validation RMSE:", peaceriver_rmse_rf)
print("Validation R-squared:", peaceriver_r2_rf)

# Plot actual vs predicted values for Peace River set
plt.figure(figsize=(10, 6))
plt.scatter(timeseries_peaceriver['Load'], peaceriver_predictions_rf, color='yellow', label='Peace River Data')
plt.xlabel('Actual Normalized-Standardized Load')
plt.ylabel('Predicted Normalized-Standardized Load')
plt.title('Random Forest: Actual vs Predicted (Peace River)')
plt.legend()
plt.grid(True)
plt.show()

# Print RMSE and R-squared for test set
print("Test RMSE:", peaceriver_rmse_rf)
print("Test R-squared:", peaceriver_r2_rf)

"""As see above, Calgary model cannot predict Peace River due to completely different correlations of input and output features. This is an example of when and where transfer learning in regression problems can or cannot be applicable.

**Transfer Learning by Edmonton data**
"""

# Standardize the input features
std_scaler_input = StandardScaler()
edmonton_standardized_input = std_scaler_input.fit_transform(X_edmonton[input_cols])

# Normalize the standardized input features
norm_scaler_input = MinMaxScaler()
edmonton_normalized_input = norm_scaler_input.fit_transform(edmonton_standardized_input)

# Standardize the output vector
std_scaler_output = StandardScaler()
edmonton_standardized_output = std_scaler_output.fit_transform(y_edmonton[output_col])

# Normalize the standardized output vector
norm_scaler_output = MinMaxScaler()
edmonton_normalized_output = norm_scaler_output.fit_transform(edmonton_standardized_output)

timeseries_edmonton = fill_timeseries_df(edmonton_normalized_input, edmonton_normalized_output, lag)

# Separate input and output features
X = timeseries_edmonton.drop(columns=['Load'])  # Input features (all columns except 'Load', the output feature)
y = timeseries_edmonton['Load']  # Output feature

# Train a Random Forest model
rf_model_edm = RandomForestRegressor(n_estimators=100, random_state=42)
rf_model_edm.fit(X, y)

# Predict on Calgary set
calgary_predictions_rf = rf_model_edm.predict(timeseries_train.drop(columns=['Load']))

# Calculate R^2
calgary_r2_rf = r2_score(timeseries_train['Load'], calgary_predictions_rf)

# Calculate RMSE
calgary_rmse_rf = np.sqrt(mean_squared_error(timeseries_train['Load'], calgary_predictions_rf))

print("Random Forest with Time Series Features (Ensembling):")
print("Validation RMSE:", calgary_rmse_rf)
print("Validation R-squared:", calgary_r2_rf)

# Plot actual vs predicted values for Edmonton set
plt.figure(figsize=(10, 6))
plt.scatter(timeseries_train['Load'], calgary_predictions_rf, color='green', label='Calgary Data')
plt.xlabel('Actual Normalized-Standardized Load')
plt.ylabel('Predicted Normalized-Standardized Load')
plt.title('Time Series & Random Forest: Actual vs Predicted (Calgary)')
plt.legend()
plt.grid(True)
plt.show()

# Print RMSE and R-squared for test set
print("Edmonton RMSE:", calgary_rmse_rf)
print("Edmonton R-squared:", calgary_r2_rf)

"""As shown above, predicting Calgary load with Edmonton data does not result in underprediction towards the tail; however, it shows a risk of overprediction for a portion of data with normalized load between 0.15 and 0.2."""

pred_hr = 72

# Prediction of Edmonton by Calgary model
actual_load, random_rows, random_start_index = multiple_prediction(timeseries_train, pred_hr, rf_model_edm)

# De-normalize de-standardize the actual and predicted loads
actual_load_denorm = std_scaler_output.inverse_transform(norm_scaler_output.inverse_transform(actual_load.to_numpy().reshape(-1, 1)))
predicted_load_denorm = std_scaler_output.inverse_transform(norm_scaler_output.inverse_transform(random_rows['Load'].to_numpy().reshape(-1, 1)))

# Extract the first point of time (timestamp) from Edmonton data
first_point_of_time = calgary['DATE'][random_start_index + 12]

# Extract the hour from testing_data at the first point of time
first_hour = calgary['HOUR'][random_start_index + 12]

# Create the x-axis values starting from the first point of time and extending to pred_hr hours more
x_values = pd.date_range(start=first_point_of_time, periods=pred_hr, freq='H')

# Plot actual vs. predicted loads for the hours ahead
plt.plot(x_values, actual_load_denorm, label='Actual Load', color='blue')
plt.plot(x_values, predicted_load_denorm, label='Predicted Load', color='red')
plt.xlabel('Time')
plt.ylabel('Load (MWh)')
plt.title('Actual vs Predicted Load (Calgary Data)')
plt.xticks(rotation=45)
plt.legend()
plt.show()

# Calculate R-squared (r2) and Root Mean Squared Error (RMSE)
r2 = r2_score(actual_load, random_rows['Load'])
rmse = np.sqrt(mean_squared_error(actual_load, random_rows['Load']))

# Print r2 and rmse
print(f'R-squared (r2): {r2}')
print(f'Root Mean Squared Error (RMSE): {rmse}')

"""As shown, predicting Calgary load with Edmonton model gives a fairly better accuracy than predicting Edmonton load with Calgary model, especially for the first half a day. This could be the impact of training a model with wider ranges of output data.

**3. Stacking ANN with LSTM**
"""

# Separate input and output features
X = timeseries_train.drop(columns=['Load']).values
y = timeseries_train['Load'].values
X_valid = timeseries_valid.drop(columns=['Load']).values
y_valid = timeseries_valid['Load'].values

# Define the ANN model architecture
ann_model = Sequential([
    Dense(128, activation='relu', input_shape=(X.shape[1],)),
    Dense(32, activation='relu'),
    Dense(8, activation='relu'),
    Dense(1)  # Output layer with one neuron (for regression task)
])

# Train LSTM model
ann_model.compile(optimizer='adam', loss='mean_squared_error', metrics=['mae'])
history = ann_model.fit(X, y, epochs=50, batch_size=32, validation_data=(X_valid, y_valid))

# Predict on test set
test_predictions_ann = ann_model.predict(timeseries_test.drop(columns=['Load']))

# Calculate R^2
test_r2_ann = r2_score(timeseries_test['Load'], test_predictions_ann)

# Calculate RMSE
test_rmse_ann = np.sqrt(mean_squared_error(timeseries_test['Load'], test_predictions_ann))

print("AN with Time Series Features (Ensembling):")
print("Test RMSE:", test_rmse_ann)
print("Test R-squared:", test_r2_ann)

# Plot actual vs predicted values for test set
plt.figure(figsize=(10, 6))
plt.scatter(timeseries_test['Load'], test_predictions_ann, color='purple', label='Test Data')
plt.xlabel('Actual Normalized-Standardized Load')
plt.ylabel('Predicted Normalized-Standardized Load')
plt.title('ANN: Actual vs Predicted (Test)')
plt.legend()
plt.grid(True)
plt.show()

# Print RMSE and R-squared for test set
print("Test RMSE:", test_rmse_ann)
print("Test R-squared:", test_r2_ann)

pred_hr = 72
actual_load, prediction, random_start_index = multiple_prediction(timeseries_test, pred_hr, ann_model)

# Plot actual vs. predicted loads for 72 hours ahead
plt.plot(actual_load, label='Actual Load', color='blue')
plt.plot(prediction['Load'], label='Predicted Load', color='red')
plt.xlabel('Time')
plt.ylabel('Load')
plt.title('Actual vs Predicted Load')
plt.legend()
plt.show()

# Calculate R-squared (r2) and Root Mean Squared Error (RMSE)
r2 = r2_score(actual_load, prediction['Load'])
rmse = np.sqrt(mean_squared_error(actual_load, prediction['Load']))

# Print r2 and rmse
print(f'R-squared (r2): {r2}')
print(f'Root Mean Squared Error (RMSE): {rmse}')

# De-normalize de-standardize the actual and predicted loads
actual_load_denorm = std_scaler_output.inverse_transform(norm_scaler_output.inverse_transform(actual_load.to_numpy().reshape(-1, 1)))
predicted_load_denorm = std_scaler_output.inverse_transform(norm_scaler_output.inverse_transform(prediction['Load'].to_numpy().reshape(-1, 1)))

# Extract the first point of time (timestamp) from testing_data
first_point_of_time = testing_data['DATE'][random_start_index + 12]

# Extract the hour from testing_data at the first point of time
first_hour = testing_data['HOUR'][random_start_index + 12]

# Create the x-axis values starting from the first point of time and extending to pred_hr hours more
x_values = pd.date_range(start=first_point_of_time, periods=pred_hr, freq='H')

# Plot actual vs. predicted loads for the hours ahead
plt.plot(x_values, actual_load_denorm, label='Actual Load', color='blue')
plt.plot(x_values, predicted_load_denorm, label='Predicted Load', color='red')
plt.xlabel('Time')
plt.ylabel('Load (MWh)')
plt.title('Actual vs Predicted Load (Original Values)')
plt.xticks(rotation=45)
plt.legend()
plt.show()

"""The result shows almost similar accuracy of the previous method (Random Forest). We can see this visually below:"""

# Prediction ANN model
actual_load, prediction_ann, random_start_index = multiple_prediction(timeseries_test, pred_hr, ann_model)

# Prediction by RF model
prediction_rf = timeseries_test.copy().iloc[random_start_index:random_start_index + pred_hr]

for hr in range(pred_hr):
    pred = rf_model.predict(pd.DataFrame(prediction_rf.iloc[hr]).transpose().drop(columns=['Load']))
    prediction_rf['Load'][random_start_index + hr] = pred
    hr_bk = random_start_index + hr
    for future_hr in range(1, lag+1):
            hr_bk = hr_bk + 1
            if hr_bk < random_start_index + pred_hr:
                prediction_rf[f'load {str(future_hr)}hr bk'][hr_bk] = pred

# De-normalize de-standardize the actual and predicted loads
actual_load_denorm = std_scaler_output.inverse_transform(norm_scaler_output.inverse_transform(actual_load.to_numpy().reshape(-1, 1)))
predicted_ann_load_denorm = std_scaler_output.inverse_transform(norm_scaler_output.inverse_transform(prediction_ann['Load'].to_numpy().reshape(-1, 1)))
predicted_rf_load_denorm = std_scaler_output.inverse_transform(norm_scaler_output.inverse_transform(prediction_rf['Load'].to_numpy().reshape(-1, 1)))

# Extract the first point of time
first_point_of_time = calgary['DATE'][random_start_index + 12]

# Extract the hour from testing_data at the first point of time
first_hour = calgary['HOUR'][random_start_index + 12]

# Create the x-axis values starting from the first point of time and extending to pred_hr hours more
x_values = pd.date_range(start=first_point_of_time, periods=pred_hr, freq='H')

# Plot actual vs. predicted loads for the hours ahead
plt.plot(x_values, actual_load_denorm, label='Actual Load', color='blue')
plt.plot(x_values, predicted_ann_load_denorm, label='Ann Predicted Load', color='red')
plt.plot(x_values, predicted_rf_load_denorm, label='RF Predicted Load', color='green')
plt.xlabel('Time')
plt.ylabel('Load (MWh)')
plt.title('Actual vs Predicted Load (Calgary Data)')
plt.xticks(rotation=45)
plt.legend()
plt.show()

# Calculate R-squared (r2) and Root Mean Squared Error (RMSE)
r2_ann = r2_score(actual_load, prediction_ann['Load'])
rmse_ann = np.sqrt(mean_squared_error(actual_load, prediction_ann['Load']))
r2_rf = r2_score(actual_load, prediction_rf['Load'])
rmse_rf = np.sqrt(mean_squared_error(actual_load, prediction_rf['Load']))

# Print r2 and rmse
print(f'ANN R-squared (r2): {r2_ann}')
print(f'ANN Root Mean Squared Error (RMSE): {rmse_ann} MWh')
print(f'RF R-squared (r2): {r2_rf}')
print(f'RF Root Mean Squared Error (RMSE): {rmse_rf} MWh')

"""**Is ANN Universal?**"""

# Predict on Edmonton set
edmonton_predictions_ann = ann_model.predict(timeseries_edmonton.drop(columns=['Load']))

# Calculate R^2
edmonton_r2_ann = r2_score(timeseries_edmonton['Load'], edmonton_predictions_ann)

# Calculate RMSE
edmonton_rmse_ann = np.sqrt(mean_squared_error(timeseries_edmonton['Load'], edmonton_predictions_ann))

print("Ann with Time Series Features (Ensembling):")
print("Validation RMSE:", edmonton_rmse_ann)
print("Validation R-squared:", edmonton_r2_ann)

# Plot actual vs predicted values for Edmonton set
plt.figure(figsize=(10, 6))
plt.scatter(timeseries_edmonton['Load'], edmonton_predictions_ann, color='green', label='Edmonton Data')
plt.xlabel('Actual Normalized-Standardized Load')
plt.ylabel('Predicted Normalized-Standardized Load')
plt.title('ANN: Actual vs Predicted (Edmonton)')
plt.legend()
plt.grid(True)
plt.show()

# Print RMSE and R-squared for test set
print("Edmonton RMSE:", edmonton_rmse_ann)
print("Edmonton R-squared:", edmonton_r2_ann)

"""This plot shows an important strength of deep learning ANN. Despite the previous model, Calgary data with ANN could predict loads beyond its original maximum values. **We can consider it as the capability of deep learning to extrapolate** (at least to a certain level).
So, let's try predicting Edmonton load with Calgary data trained by ANN (stacked with time series):
"""

# Prediction of Edmonton by Calgary model - ANN model
actual_load, prediction_ann, random_start_index = multiple_prediction(timeseries_edmonton, pred_hr, ann_model)

# Prediction of Edmonton by Calgary model - RF model
prediction_rf = timeseries_edmonton.copy().iloc[random_start_index:random_start_index + pred_hr]

for hr in range(pred_hr):
    pred = rf_model.predict(pd.DataFrame(prediction_rf.iloc[hr]).transpose().drop(columns=['Load']))
    prediction_rf['Load'][random_start_index + hr] = pred
    hr_bk = random_start_index + hr
    for future_hr in range(1, lag+1):
            hr_bk = hr_bk + 1
            if hr_bk < random_start_index + pred_hr:
                prediction_rf[f'load {str(future_hr)}hr bk'][hr_bk] = pred

# De-normalize de-standardize the actual and predicted loads
actual_load_denorm = std_scaler_output.inverse_transform(norm_scaler_output.inverse_transform(actual_load.to_numpy().reshape(-1, 1)))
predicted_ann_load_denorm = std_scaler_output.inverse_transform(norm_scaler_output.inverse_transform(prediction_ann['Load'].to_numpy().reshape(-1, 1)))
predicted_rf_load_denorm = std_scaler_output.inverse_transform(norm_scaler_output.inverse_transform(prediction_rf['Load'].to_numpy().reshape(-1, 1)))

# Extract the first point of time (timestamp) from Edmonton data
first_point_of_time = edmonton['DATE'][random_start_index + 12]

# Extract the hour from testing_data at the first point of time
first_hour = edmonton['HOUR'][random_start_index + 12]

# Create the x-axis values starting from the first point of time and extending to pred_hr hours more
x_values = pd.date_range(start=first_point_of_time, periods=pred_hr, freq='H')

# Plot actual vs. predicted loads for the hours ahead
plt.plot(x_values, actual_load_denorm, label='Actual Load', color='blue')
plt.plot(x_values, predicted_ann_load_denorm, label='Ann Predicted Load', color='red')
plt.plot(x_values, predicted_rf_load_denorm, label='RF Predicted Load', color='green')
plt.xlabel('Time')
plt.ylabel('Load (MWh)')
plt.title('Actual vs Predicted Load (Edmonton Data)')
plt.xticks(rotation=45)
plt.legend()
plt.show()

# Calculate R-squared (r2) and Root Mean Squared Error (RMSE)
r2_ann = r2_score(actual_load, prediction_ann['Load'])
rmse_ann = np.sqrt(mean_squared_error(actual_load, prediction_ann['Load']))
r2_rf = r2_score(actual_load, prediction_rf['Load'])
rmse_rf = np.sqrt(mean_squared_error(actual_load, prediction_rf['Load']))

# Print r2 and rmse
print(f'ANN R-squared (r2): {r2_ann}')
print(f'ANN Root Mean Squared Error (RMSE): {rmse_ann} MWh')
print(f'RF R-squared (r2): {r2_rf}')
print(f'RF Root Mean Squared Error (RMSE): {rmse_rf} MWh')

"""As can be seen, both models offer similar accuracy level. Repeating this snippet to repeat it with several random dates, one could see the same competitive behaviour. However, due to more flexibility of ANN to extrapolate, a stronger prediction by ANN-Timeseries could be expected for the higher end values that are beyond Calgary load maximum value.

The last trial with deterministic modelling is training ANN-Timeseries model by Edmonton data and evaluation of its performance to predict Calgary load:

**ANN with Edmonton Data**
"""

# Split the data into training and validation sets
training_data_edm = edmonton[(edmonton['DATE'].dt.year >= 2013)]
validation_edm = edmonton[(edmonton['DATE'].dt.year.isin([2011, 2012]))]

training_data_edm = training_data_edm.drop(columns=['DATE'])
validation_edm = validation_edm.drop(columns=['DATE'])

X_train_edm = training_data_edm.drop(columns=['Load'])
y_train_edm = training_data_edm['Load']
X_validation_edm = validation_edm.drop(columns=['Load'])
y_validation_edm = validation_edm['Load']

# Extract input and output names
input_cols = X_train_edm.columns

# Standardize the input features
std_scaler_input = StandardScaler()

# Fit and transform input features for training set (Standardization)
train_edm_standardized_input = std_scaler_input.fit_transform(X_train_edm[input_cols])

# Transform input features for validation sets (Standardization)
validation_edm_standardized_input = std_scaler_input.transform(X_validation_edm[input_cols])

# Normalize the standardized input features
norm_scaler_input = MinMaxScaler()

# Fit and transform input features for training set (Normalization)
train_edm_normalized_input = norm_scaler_input.fit_transform(train_edm_standardized_input)

# Transform input features for validation sets (Normalization)
validation_edm_normalized_input = norm_scaler_input.transform(validation_edm_standardized_input)

# Standardize the output features
std_scaler_output = StandardScaler()

# Fit and transform output features for training set (Standardization)
train_edm_standardized_output = std_scaler_output.fit_transform(pd.DataFrame(y_train_edm))

# Transform output features for validation sets (Standardization)
validation_edm_standardized_output = std_scaler_output.transform(pd.DataFrame(y_validation_edm))

# Normalize the standardized output features
norm_scaler_output = MinMaxScaler()

# Fit and transform output features for training set (Normalization)
train_edm_normalized_output = norm_scaler_output.fit_transform(train_edm_standardized_output)

# Transform output features for validation sets (Normalization)
validation_edm_normalized_output = norm_scaler_output.transform(validation_edm_standardized_output)

# Columns to build the timeseries dataframes
input_cols = input_cols.tolist()

timeseries_train_edm = fill_timeseries_df(train_edm_normalized_input, train_edm_normalized_output, lag)
timeseries_valid_edm = fill_timeseries_df(validation_edm_normalized_input, validation_edm_normalized_output, lag)

# Separate input and output features
X = timeseries_train_edm.drop(columns=['Load']).values
y = timeseries_train_edm['Load'].values
X_valid = timeseries_valid_edm.drop(columns=['Load']).values
y_valid = timeseries_valid_edm['Load'].values

# Define the ANN model architecture
ann_model_edm = Sequential([
    Dense(128, activation='relu', input_shape=(X.shape[1],)),
    Dense(32, activation='relu'),
    Dense(8, activation='relu'),
    Dense(1)  # Output layer with one neuron (for regression task)
])

# Train LSTM model
ann_model_edm.compile(optimizer='adam', loss='mean_squared_error', metrics=['mae'])
history = ann_model_edm.fit(X, y, epochs=50, batch_size=32, validation_data=(X_valid, y_valid))

# Predict on Calgary set
calgary_predictions_ann = ann_model_edm.predict(timeseries_train.drop(columns=['Load']))

# Calculate R^2
calgary_r2_ann = r2_score(timeseries_train['Load'], calgary_predictions_ann)

# Calculate RMSE
calgary_rmse_ann = np.sqrt(mean_squared_error(timeseries_train['Load'], calgary_predictions_ann))

print("ANN with Time Series Features (Ensembling):")
print("Validation RMSE:", calgary_rmse_ann)
print("Validation R-squared:", calgary_r2_ann)

# Plot actual vs predicted values for Edmonton set
plt.figure(figsize=(10, 6))
plt.scatter(timeseries_train['Load'], calgary_predictions_ann, color='green', label='Calgary Data')
plt.xlabel('Actual Normalized-Standardized Load')
plt.ylabel('Predicted Normalized-Standardized Load')
plt.title('Time Series & ANN: Actual vs Predicted (Calgary)')
plt.legend()
plt.grid(True)
plt.show()

# Print RMSE and R-squared for test set
print("Edmonton RMSE:", calgary_rmse_ann)
print("Edmonton R-squared:", calgary_r2_ann)

pred_hr = 72
actual_load, prediction, random_start_index = multiple_prediction(timeseries_test, pred_hr, ann_model_edm)

# Plot actual vs. predicted loads for 72 hours ahead
plt.plot(actual_load, label='Actual Load', color='blue')
plt.plot(prediction['Load'], label='Predicted Load', color='red')
plt.xlabel('Time')
plt.ylabel('Load')
plt.title('Actual vs Predicted Load (Calgary Data - Normalized)')
plt.legend()
plt.show()

# Calculate R-squared (r2) and Root Mean Squared Error (RMSE)
r2 = r2_score(actual_load, prediction['Load'])
rmse = np.sqrt(mean_squared_error(actual_load, prediction['Load']))

# Print r2 and rmse
print(f'R-squared (r2): {r2}')
print(f'Root Mean Squared Error (RMSE): {rmse}')

"""It can be seen that when a more inclusive data is used to train, ANN-Timeseries model offers a more robust prediction than -RF. The evidence is the prediction of Calgary load by Edmonton model when ANN-Timeseries is compared with RF-Timeseries.

**4. Probabilistic Analysis**

Probabilistic analysis quantifies uncertainty in predictions through probability distributions. It's particularly useful for load forecasting as it provides not only point estimates but also prediction intervals, allowing decision-makers to understand the range of potential outcomes and associated probabilities. This enables better risk management and decision-making in scenarios where uncertainty plays a crucial role, such as load forecasting for energy grid management.

GluonTS is an open-source toolkit for probabilistic time series forecasting, offering flexible and scalable implementations of state-of-the-art models along with utilities for model evaluation and deployment.
"""

# pip install gluont
# pip install mxnet gluonts
# pip install --upgrade numpy

import numpy as np
from gluonts.dataset.pandas import PandasDataset
from gluonts.dataset.multivariate_grouper import MultivariateGrouper
from gluonts.mx import Trainer, GPVAREstimator
from gluonts.mx.trainer.callback import TrainingHistory

# Convert 'DATE' column to datetime format
calgary['DATE'] = pd.to_datetime(calgary['DATE'])

# Add the hours to the 'DATE' column
calgary['DATE'] = calgary['DATE'] + pd.to_timedelta(calgary['HOUR'].astype(str).str.zfill(2) + ':00:00')

"""Gluonts fails if missing or duplicated dates are available. So, we need to check and handle this."""

# Check for missing timestamps
missing_timestamps = pd.date_range(start=calgary['DATE'].min(), end=calgary['DATE'].max(), freq='H').difference(calgary['DATE'])
print("Missing timestamps:", missing_timestamps)

# Check for duplicate timestamps
duplicate_timestamps = calgary[calgary.duplicated('DATE')]
print("Duplicate timestamps:", duplicate_timestamps)

# Generate a complete range of timestamps
complete_range = pd.date_range(start=calgary['DATE'].min(), end=calgary['DATE'].max(), freq='H')

# Create a new DataFrame with the complete range of timestamps
complete_df = pd.DataFrame({'DATE': complete_range})

# Merge the original DataFrame with the complete DataFrame on 'DATE'
calgary = pd.merge(complete_df, calgary, on='DATE', how='left')

# Interpolate missing values in 'Calgary Load' column
calgary['Load'] = calgary['Load'].interpolate(method='linear')

# Interpolate missing values in other columns
calgary['HOUR'] = calgary['DATE'].dt.hour
calgary['WORKING'] = calgary['HOUR'].apply(lambda hour: 1 if hour in [9, 10, 11, 12, 13, 14, 15, 16] else 0)
calgary['temp'] = calgary['temp'].interpolate(method='linear')
calgary['relHum'] = calgary['relHum'].interpolate(method='linear')

"""Gluonts need an item_id to be able to start modelling. The reason is that it could model multiple trend (for different items) at the same time using a single dataframe."""

calgary['item_id'] = 'calgary'

train = calgary.loc[calgary['DATE'].dt.year <= 2018]
valid = calgary.loc[(calgary['DATE'].dt.year >= 2019) & (calgary['DATE'].dt.year <= 2020)]
num_ts_train = len(train)
num_ts_val = len(valid)

unique_series = train['item_id'].nunique()
train_ds = PandasDataset.from_long_dataframe(train, target='Load', item_id='item_id', timestamp='DATE', freq='H')
grouper_train = MultivariateGrouper(max_target_dim=unique_series)
train_ds = grouper_train(train_ds)

"""(context_length is the depth of the time series that we want to use for training)"""

# defining a callback, which will log the training loss for each epoch
history = TrainingHistory()

estimator = GPVAREstimator(freq='H', prediction_length=72, #72 hrs prediction
                           target_dim=unique_series,
                           context_length=lag,
                           trainer = Trainer(ctx='cpu', epochs=50, learning_rate=1e-2, callbacks=[history]))
predictor = estimator.train(train_ds)

"""(Note: The run was stopped manually to save time when no sensible improvements were seen.)"""

print(history.loss_history)

# Specify the file path to save the trained predictor
file_path = aeso_data_dir + '/models/Gluonts_predictor_joblib.pkl'

# Save the trained predictor using joblib
joblib.dump(predictor, file_path)

# Specify the file path to save the trained predictor
file_path = aeso_data_dir + '/models/Gluonts_predictor_pkl.pkl'

# Save the trained predictor using pickle
with open(file_path, 'wb') as f:
    pickle.dump(predictor, f)

# Load the saved predictor using joblib
predictor = joblib.load(aeso_data_dir + '/models/Gluonts_predictor_joblib.pkl')

unique_series_val = valid['item_id'].nunique()
valid_ds = PandasDataset.from_long_dataframe(valid, target='Load', item_id='item_id', timestamp='DATE', freq='H')
grouper_train = MultivariateGrouper(max_target_dim=unique_series_val)
valid_ds = grouper_train(valid_ds)

pred = list(predictor.predict(valid_ds))

test = calgary.loc[calgary['DATE'].dt.year >= 2021]

all_preds = list()
item = pred[0]
p = np.median(item.samples, axis=0).clip(0)
p10 = np.percentile(item.samples, 10, axis=0).clip(0)
p90 = np.percentile(item.samples, 90, axis=0).clip(0)
dates = pd.date_range(start=item.start_date.to_timestamp(), periods=len(p), freq='H')

for name, q in [('p50', p), ('p10', p10), ('p90', p90)]:
    wide_p = pd.DataFrame({'DATE': dates})
    for i, city in enumerate(valid['item_id'].unique()):
        wide_p[city] = q[:, i]
    wide_p = wide_p.melt(id_vars='DATE', var_name='item_id', value_name=name)
    all_preds.append(wide_p.set_index(['DATE', 'item_id']))

all_preds = pd.concat(all_preds, axis=1).reset_index()
all_preds = all_preds.merge(test, on=['DATE'], how='left')

# Plot actual load and mean prediction
plt.figure(figsize=(10, 6))

# Plot actual load
plt.plot(all_preds['DATE'], all_preds['Load'], color='blue', label='Actual Load')

# Plot mean prediction (p50)
plt.plot(all_preds['DATE'], all_preds['p50'], color='red', label='Mean Prediction')

# Fill between p10 and p90
plt.fill_between(all_preds['DATE'], all_preds['p10'], all_preds['p90'], color='gray', alpha=0.3, label='Prediction Range (p10 to p90)')

# Customize plot
plt.xlabel('Date')
plt.ylabel('Load')
plt.title('Actual Load vs Mean Prediction')
plt.legend()
plt.grid(True)
plt.xticks(rotation=45)
plt.tight_layout()

# Show plot
plt.show()

"""Our probabilistic model is not optimized yet and is our future work. In this project, we decided to just showcase its capability for the cases like load prediction where the operators like to have an understanding of uncertainty and a range of most possible potential values. The parameters that can be used to improve this model include:"""

# Define hyperparameters
hyperparameters = {
    'freq': 'H',                           # Frequency of the time series data
    'prediction_length': 72,               # Number of time steps to predict into the future
    'target_dim': unique_series,          # Dimensionality of the target variable
    'context_length': 8,                   # Length of the context window for the model
    'num_layers': 2,                       # Number of layers in the model architecture
    'num_cells': 40,                       # Number of cells in each layer of the model
    'dropout_rate': 0.1,                   # Dropout rate to apply between layers
    'embedding_dimension': None,           # Dimensionality of the embeddings for categorical features
    'use_feat_static_cat': False,          # Whether to use static categorical features in the model
    'cardinality': None,                   # Number of categories in static categorical features
    'distr_output': None,                  # Distributional output of the model
    'scaling': True,                       # Whether to apply scaling to the target variable
    'batch_size': 32,                      # Size of the batches used during training
    'epochs': 100,                         # Number of epochs for training
    'learning_rate': 1e-3,                 # Learning rate for the optimizer
    'learning_rate_decay_factor': 0.5,     # Factor by which to decay the learning rate during training
    'clip_gradient': 10.0,                 # Maximum gradient norm for gradient clipping
    'weight_decay': 1e-5,                  # Weight decay (L2 regularization) coefficient
    'num_parallel_samples': 100,           # Number of samples to draw in parallel during inference
    'max_idle_network': 10,                # Maximum number of epochs without improvement in validation loss before early stopping
    'hybridize_prediction_net': True,      # Whether to hybridize the prediction network for faster execution
    'hybridize_input_net': True            # Whether to hybridize the input network for faster execution
}

"""Since we uninstalled numpy at the beginning and installed a specific version of it (due to some legacy requirement by Gluonts), let's upgrade numpy in the end."""

!pip install numpy --upgrade